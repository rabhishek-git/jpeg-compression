<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JPEG Image Compressor</title>
    <!-- Google AdSense Script (MUST REPLACE ca-pub-XXXXXXXXXXXXXXXX with your actual Publisher ID) -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXXXXXXXXXXXXX" crossorigin="anonymous"></script>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Montserrat (for general text and bold headings) -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;600;700;900&display=swap" rel="stylesheet">
    <!-- Firebase CDN Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, increment } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Make Firebase modules globally accessible for the Babel script
        window.firebase = {
            initializeApp,
            getAuth,
            signInAnonymously,
            signInWithCustomToken,
            onAuthStateChanged,
            getFirestore,
            doc,
            setDoc,
            onSnapshot,
            increment
        };
    </script>
    <style>
        body {
            background-color: #000; /* Solid black base */
            background-image: url('data:image/svg+xml,%3Csvg width="100%25" height="100%25" xmlns="http://www.w3.org/2000/svg"%3E%3Cdefs%3E%3Cpattern id="smallGrid" width="10" height="10" patternUnits="userSpaceOnUse"%3E%3Cpath d="M 10 0 L 0 0 0 10" fill="none" stroke="%23222" stroke-width="0.5"/%3E%3C/pattern%3E%3Cpattern id="grid" width="100" height="100" patternUnits="userSpaceOnUse"%3E%3Crect width="100" height="100" fill="url(%23smallGrid)"/%3E%3Cpath d="M 100 0 L 0 0 0 100" fill="none" stroke="%23444" stroke-width="1"/%3E%3C/pattern%3E%3C/defs%3E%3Crect width="100%25" height="100%25" fill="url(%23grid)"/%3E%3C/svg%3E');
            background-size: cover;
            font-family: 'Montserrat', sans-serif; /* New default font */
            color: #E0E0E0; /* Light gray text */
        }
        /* Main title text styling */
        .app-title {
            font-family: 'Montserrat', sans-serif;
            font-weight: 900; /* Extra bold */
            /* This gradient will be overridden by inline style for dynamic color */
            background: linear-gradient(to bottom, #FFD700, #B8860B, #DAA520);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            color: transparent;
            text-shadow: 2px 2px 5px rgba(0,0,0,0.5); /* Subtle shadow for depth */
        }
        /* Logo text styling */
        .logo-text {
            font-family: 'Montserrat', sans-serif;
            font-weight: 700;
            background: linear-gradient(to right, #00F0FF, #FF00FF, #FFFF00); /* Vibrant gradient for logo */
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            color: transparent;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
        }

        /* Custom styles for range input thumb */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-color); /* Dynamic accent color */
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(var(--accent-rgb), 0.3);
            transition: background .15s ease-in-out, box-shadow .15s ease-in-out;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-color); /* Dynamic accent color */
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(var(--accent-rgb), 0.3);
            transition: background .15s ease-in-out, box-shadow .15s ease-in-out;
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            background: var(--accent-color-dark); /* Darker dynamic accent */
        }
        input[type="range"]::-moz-range-thumb:hover {
            background: var(--accent-color-dark); /* Darker dynamic accent */
        }
        input[type="range"] {
            accent-color: var(--accent-color); /* Dynamic accent color for track fill */
        }

        /* Custom CSS for the spinning animation */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .animate-spin-slow {
            animation: spin 1.5s linear infinite;
        }

        /* New CSS for continuous button animation */
        @keyframes pulse-glow {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(var(--accent-rgb), 0.7); /* Dynamic accent with opacity */
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 0 8px rgba(var(--accent-rgb), 0); /* transparent */
                transform: scale(1.02);
            }
        }
        .animate-pulse-glow {
            animation: pulse-glow 2s infinite ease-in-out;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <!-- React and ReactDOM CDN -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel for JSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
        // Destructure React hooks from the global React object
        const { useState, useCallback, useEffect, useRef } = React;

        // Destructure Firebase modules from the global window object
        const { initializeApp, getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, getFirestore, doc, setDoc, onSnapshot, increment } = window.firebase;

        // AdSense Ad Component
        const AdSenseAd = ({ client, slot, format = 'auto', responsive = true }) => {
            const adRef = useRef(null); // Ref to the ins element

            useEffect(() => {
                const loadAd = () => {
                    try {
                        // Only push if the element has a width and adsbygoogle is available
                        if (adRef.current && adRef.current.offsetWidth > 0 && window.adsbygoogle) {
                            (window.adsbygoogle = window.adsbygoogle || []).push({});
                        } else if (!window.adsbygoogle) {
                            console.warn('adsbygoogle not found. AdSense might not load.');
                        }
                    } catch (e) {
                        console.error('Error pushing AdSense ad:', e);
                    }
                };

                // Use a setTimeout to ensure the DOM has rendered and calculated dimensions
                const timer = setTimeout(loadAd, 100); // Small delay

                // Add a listener for window resize to try loading ads again
                window.addEventListener('resize', loadAd);

                return () => {
                    clearTimeout(timer);
                    window.removeEventListener('resize', loadAd);
                };
            }, [client, slot]); // Re-run effect if client or slot changes (though unlikely for static ads)

            return (
                <ins className="adsbygoogle"
                    ref={adRef} // Attach ref to the ins element
                    style={{ display: 'block', textAlign: 'center' }} // Centered display
                    data-ad-client={client}
                    data-ad-slot={slot}
                    data-ad-format={format}
                    data-full-width-responsive={responsive ? 'true' : 'false'}
                ></ins>
            );
        };


        // Main App component
        const App = () => {
            // uploadedFiles now includes 'status', 'originalSize', 'compressedSize', and 'compressedPreviewUrl' properties
            const [uploadedFiles, setUploadedFiles] = useState([]);
            const [isDragging, setIsDragging] = useState(false);
            const fileInputRef = useRef(null);
            const [compressionQuality, setCompressionQuality] = useState(0); // 0% compression = no change (100% quality)
            // State to track if any files are currently being "processed"
            const [isProcessing, setIsProcessing] = useState(false);
            // New state for the zoomed image: { url: string, name: string, type: 'original' | 'compressed' }
            const [zoomedImage, setZoomedImage] = useState(null);
            // NEW: State to track if compression has been initiated at least once
            const [compressionInitiated, setCompressionInitiated] = useState(false);
            // State for dynamic accent color
            const [dominantAccentColor, setDominantAccentColor] = useState({ hex: '#4A90E2', rgb: '74, 144, 226' }); // Default blue
            // New state for original file size to display in slider section
            const [currentOriginalFileSize, setCurrentOriginalFileSize] = useState(null);
            // New state for estimated compressed size
            const [estimatedCompressedSize, setEstimatedCompressedSize] = useState(null);
            // New state for compression mode: 'quality' or 'filesize'
            const [compressionMode, setCompressionMode] = useState('quality'); // Default to quality mode
            // New state for target file size in bytes when in 'filesize' mode
            const [targetFileSizeInBytes, setTargetFileSizeInBytes] = useState(0); 
            // New state for output format: 'image/jpeg', 'image/png', 'image/webp'
            const [outputFormat, setOutputFormat] = useState('image/jpeg'); // Default to JPEG

            // Firebase states
            const [db, setDb] = useState(null);
            const [auth, setAuth] = useState(null);
            const [userId, setUserId] = useState(null);
            const [visitorCount, setVisitorCount] = useState(0);
            const [totalFilesConverted, setTotalFilesConverted] = useState(0); // New state for converted files
            const [isAuthReady, setIsAuthReady] = useState(false); // New state to track auth readiness

            // Max number of files to "process" concurrently (simulated)
            const MAX_CONCURRENT_PROCESSES = 3;
            // New: Maximum allowed file size in MB
            const MAX_FILE_SIZE_MB = 10;
            const MAX_FILE_SIZE_BYTES = MAX_FILE_SIZE_MB * 1024 * 1024; // Convert MB to Bytes

            // Helper to format file size
            const formatBytes = (bytes, decimals = 2) => {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const dm = decimals < 0 ? 0 : decimals;
                const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
            };

            // Helper to set CSS variables for dynamic accent colors
            const setCssAccentColors = useCallback((hex, rgb) => {
                document.documentElement.style.setProperty('--accent-color', hex);
                document.documentElement.style.setProperty('--accent-rgb', rgb);
                // Calculate a slightly darker version for hover states
                const r = parseInt(rgb.split(',')[0].trim());
                const g = parseInt(rgb.split(',')[1].trim());
                const b = parseInt(rgb.split(',')[2].trim());
                const darkerHex = `#${((1 << 24) + (Math.floor(r * 0.8) << 16) + (Math.floor(g * 0.8) << 8) + (Math.floor(b * 0.8))).toString(16).slice(1).toUpperCase()}`;
                document.documentElement.style.setProperty('--accent-color-dark', darkerHex);
            }, []);

            // Initial useEffect for setting default colors on load
            useEffect(() => {
                setCssAccentColors('#4A90E2', '74, 144, 226'); // Set initial default blue
            }, [setCssAccentColors]);


            // Function to calculate estimated compressed size based on user's compression percentage (0-100)
            const calculateEstimatedCompressedSize = useCallback((originalSize, userCompressionPercentage) => {
                if (originalSize === null) return null;
                // Map userCompressionPercentage (0-100) to canvas quality (100-10)
                // 0% compression -> 100 quality (least compression, largest file)
                // 100% compression -> 10 quality (most compression, smallest file)
                const canvasQuality = 100 - (userCompressionPercentage * 0.9); // Range 10 to 100

                let simulatedCompressedSize;
                // This is a simplified, approximate model for simulation.
                // Actual JPEG compression is complex and depends on image content.
                // A linear mapping of canvasQuality to file size reduction.
                // Let's assume 100 quality is ~95% of original size, and 10 quality is ~5% of original size.
                const maxRatio = 0.95; // Max file size ratio (for 0% compression / 100 canvas quality)
                const minRatio = 0.05; // Min file size ratio (for 100% compression / 10 canvas quality)

                // Normalize canvasQuality from [10, 100] to [0, 1]
                const normalizedQuality = (canvasQuality - 10) / (100 - 10); // 0 for 10 quality, 1 for 100 quality

                // Interpolate ratio based on normalized quality
                const ratio = minRatio + (maxRatio - minRatio) * normalizedQuality;
                simulatedCompressedSize = originalSize * ratio;

                return Math.max(1000, simulatedCompressedSize); // Ensure a minimum size (1KB)
            }, []);

            // Function to estimate user's compression percentage (0-100) based on target file size in bytes
            const estimateUserCompressionPercentageFromTargetSize = useCallback((originalSize, targetSizeInBytes) => {
                if (originalSize === 0) return 0; // Avoid division by zero
                const targetRatio = targetSizeInBytes / originalSize;

                const minCanvasQuality = 10;
                const maxCanvasQuality = 100;
                const minRatio = 0.05;
                const maxRatio = 0.95;

                // Normalize targetRatio to [0, 1] based on our min/max simulated ratios
                let normalizedTargetRatio = (targetRatio - minRatio) / (maxRatio - minRatio);
                normalizedTargetRatio = Math.max(0, Math.min(1, normalizedTargetRatio));

                // Interpolate canvasQuality from normalized ratio
                const estimatedCanvasQuality = minCanvasQuality + (maxCanvasQuality - minCanvasQuality) * normalizedTargetRatio;

                // Convert canvas quality back to user compression percentage
                // userCompressionPercentage = (100 - estimatedCanvasQuality) / 0.9
                const userCompressionPercentage = (100 - estimatedCanvasQuality) / 0.9;
                return Math.round(Math.max(0, Math.min(100, userCompressionPercentage)));
            }, []);


            // Handle files dropped or selected via input
            const handleFiles = useCallback(async (files) => {
                const newValidFiles = [];
                const warnings = [];
                let imageCounter = uploadedFiles.length; // Start counter from current number of files

                for (const file of Array.from(files)) {
                    // Check if the file type is supported for input
                    if (!['image/jpeg', 'image/png', 'image/webp'].includes(file.type)) {
                        warnings.push(`"${file.name}" is not a supported image format (JPEG, PNG, WebP) and will be skipped.`);
                    } else if (file.size > MAX_FILE_SIZE_BYTES) {
                        warnings.push(`"${file.name}" (${formatBytes(file.size)}) exceeds the ${MAX_FILE_SIZE_MB} MB limit and will be skipped.`);
                    } else {
                        imageCounter++;
                        const previewUrl = URL.createObjectURL(file);
                        newValidFiles.push({
                            id: file.name + '-' + file.size + '-' + Date.now(), // Unique ID for keying and tracking
                            originalFileName: file.name, // Store original file name
                            displayFileName: `Image ${imageCounter}`, // New: Display name for the image
                            file,
                            previewUrl,
                            status: 'uploaded', // Initial status is now 'uploaded'
                            originalSize: file.size, // Store original size
                            compressedSize: null, // Will be set after "compression"
                            compressedPreviewUrl: null, // Will be set after "compression"
                            dimensions: { width: null, height: null }, // New: Store image dimensions
                        });
                    }
                }

                if (warnings.length > 0) {
                    alert('Some files were skipped:\n' + warnings.join('\n'));
                }

                setUploadedFiles(prevFiles => {
                    const currentTotalFiles = prevFiles.length;
                    const updatedFiles = [...prevFiles, ...newValidFiles];

                    // Set accent color to "call to action" gold if new files are added and no compression initiated
                    if (currentTotalFiles === 0 && newValidFiles.length > 0 && !compressionInitiated) {
                        setDominantAccentColor({ hex: '#FFD700', rgb: '255, 215, 0' });
                        setCssAccentColors('#FFD700', '255, 215, 0');
                    }

                    // Update currentOriginalFileSize and estimatedCompressedSize based on the first file
                    if (updatedFiles.length > 0) {
                        const firstFileOriginalSize = updatedFiles[0].originalSize;
                        setCurrentOriginalFileSize(firstFileOriginalSize);
                        // Initialize targetFileSizeInBytes to original size for 'filesize' mode
                        setTargetFileSizeInBytes(firstFileOriginalSize);
                        // Calculate initial estimated compressed size based on current quality slider value (which is user's compression %)
                        setEstimatedCompressedSize(calculateEstimatedCompressedSize(firstFileOriginalSize, compressionQuality));
                    } else {
                        setCurrentOriginalFileSize(null);
                        setEstimatedCompressedSize(null);
                        setTargetFileSizeInBytes(0);
                    }
                    return updatedFiles;
                });
                setCompressionInitiated(false); // Reset compression initiated state on new file uploads
            }, [MAX_FILE_SIZE_BYTES, MAX_FILE_SIZE_MB, uploadedFiles.length, compressionQuality, compressionInitiated, setCssAccentColors, calculateEstimatedCompressedSize]);

            // Drag event handlers
            const handleDragEnter = useCallback((e) => {
                e.preventDefault();
                e.stopPropagation();
                setIsDragging(true);
            }, []);

            const handleDragLeave = useCallback((e) => {
                e.preventDefault();
                e.stopPropagation();
                if (!e.currentTarget.contains(e.relatedTarget)) {
                    setIsDragging(false);
                }
            }, []);

            const handleDragOver = useCallback((e) => {
                e.preventDefault();
                e.stopPropagation();
                setIsDragging(true);
            }, []);

            const handleDrop = useCallback((e) => {
                e.preventDefault();
                e.stopPropagation();
                setIsDragging(false);
                if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                    handleFiles(e.dataTransfer.files);
                    e.dataTransfer.clearData();
                }
            }, [handleFiles]);

            // Handle file input change
            const handleFileInputChange = useCallback((e) => {
                if (e.target.files && e.target.files.length > 0) {
                    handleFiles(e.target.files);
                    e.target.value = null; // Clear input value to allow re-uploading same files
                }
            }, [handleFiles]);

            // Trigger file input click when drop area is clicked
            const handleDropAreaClick = useCallback(() => {
                fileInputRef.current?.click();
            }, []);

            // Handle slider change (for both quality and file size modes)
            const handleSliderChange = useCallback((e) => {
                const newValue = Number(e.target.value); // This is either userCompressionPercentage or targetFileSizeInBytes
                
                if (currentOriginalFileSize === null) return; // Cannot calculate without an original file

                if (compressionMode === 'quality') {
                    setCompressionQuality(newValue); // newValue is userCompressionPercentage (0-100)
                    setEstimatedCompressedSize(calculateEstimatedCompressedSize(currentOriginalFileSize, newValue));
                } else { // compressionMode === 'filesize'
                    setTargetFileSizeInBytes(newValue); // newValue is targetFileSizeInBytes
                    // Calculate the userCompressionPercentage based on the new target size
                    const userCompPercent = estimateUserCompressionPercentageFromTargetSize(currentOriginalFileSize, newValue);
                    setCompressionQuality(userCompPercent); // Update compressionQuality state, which will be used by processFile
                    setEstimatedCompressedSize(newValue); // Estimated is now the target
                }
            }, [compressionMode, currentOriginalFileSize, calculateEstimatedCompressedSize, estimateUserCompressionPercentageFromTargetSize]);

            // Function to handle output format change
            const handleOutputFormatChange = useCallback((format) => {
                setOutputFormat(format);
                // When format changes, re-evaluate estimated size based on current quality or target size
                if (currentOriginalFileSize !== null) {
                    if (compressionMode === 'quality') {
                        setEstimatedCompressedSize(calculateEstimatedCompressedSize(currentOriginalFileSize, compressionQuality));
                    } else {
                        setEstimatedCompressedSize(targetFileSizeInBytes); // Already set by targetFileSizeInBytes
                        setCompressionQuality(estimateUserCompressionPercentageFromTargetSize(currentOriginalFileSize, targetFileSizeInBytes));
                    }
                }
            }, [currentOriginalFileSize, compressionMode, compressionQuality, targetFileSizeInBytes, calculateEstimatedCompressedSize, estimateUserCompressionPercentageFromTargetSize]);


            // Function to simulate processing a single file
            const processFile = useCallback(async (fileToProcess) => {
                let currentFileStatus = 'processing'; // Default to processing initially
                setUploadedFiles(prevFiles =>
                    prevFiles.map(f =>
                        f.id === fileToProcess.id ? { ...f, status: currentFileStatus } : f
                    )
                );

                console.log(`Simulating compression for: ${fileToProcess.displayFileName} (User Compression: ${compressionQuality}%) to ${outputFormat}`);

                // Simulate network request/backend processing time
                await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 1000)); // 1.5 to 2.5 seconds delay

                let simulatedCompressedSize = null;
                let compressedDataUrl = null;
                let imageDimensions = { width: null, height: null };
                
                try {
                    // Read file as ArrayBuffer to get actual byte size for simulation
                    const arrayBuffer = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsArrayBuffer(fileToProcess.file);
                    });

                    // Calculate canvasQuality from user's compressionQuality (0-100)
                    // 0% comp -> 100 quality (least compression, largest file)
                    // 100% comp -> 10 quality (most compression, smallest file)
                    const canvasQuality = 100 - (compressionQuality * 0.9); // Range 10 to 100

                    // Simulate compressed size based on canvasQuality (for display purposes)
                    const originalBytes = arrayBuffer.byteLength;
                    const maxRatio = 0.95;
                    const minRatio = 0.05;
                    const normalizedQuality = (canvasQuality - 10) / (100 - 10);
                    const ratio = minRatio + (maxRatio - minRatio) * normalizedQuality;
                    simulatedCompressedSize = originalBytes * ratio;
                    simulatedCompressedSize = Math.max(1000, simulatedCompressedSize); // Ensure a minimum size (1KB)


                    // Use FileReader to get Base64 data URL for canvas processing
                    const base64DataUrl = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(fileToProcess.file);
                    });

                    const img = new Image();
                    await Promise.race([
                        new Promise((resolve, reject) => {
                            img.onload = () => {
                                if (img.naturalWidth > 0 && img.naturalHeight > 0) {
                                    imageDimensions = { width: img.naturalWidth, height: img.naturalHeight };
                                    resolve();
                                } else {
                                    reject(new Error("Image loaded with invalid dimensions."));
                                }
                            };
                            img.onerror = () => {
                                console.error("Image failed to load for canvas processing (onerror):", fileToProcess.displayFileName);
                                reject(new Error("Image load error"));
                            };
                            img.src = base64DataUrl; // Use the Base64 data URL
                        }),
                        new Promise((_, reject) =>
                            setTimeout(() => reject(new Error("Image load timeout")), 5000)
                        )
                    ]);

                    await img.decode(); // Ensure image is fully decoded

                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.naturalWidth;
                    canvas.height = img.naturalHeight;
                    ctx.drawImage(img, 0, 0);
                    
                    // Use the calculated canvasQuality for actual compression for all formats
                    // PNG quality parameter is often ignored or used differently by browsers, but we pass it for consistency.
                    // WebP quality parameter behaves similarly to JPEG.
                    compressedDataUrl = canvas.toDataURL(outputFormat, canvasQuality / 100);
                    console.log("Generated compressed data URL for download:", compressedDataUrl.substring(0, 50) + "...");
                    currentFileStatus = 'completed';

                    // Increment total files converted if db is available
                    if (db) {
                        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                        const convertedCountDocRef = doc(db, `artifacts/${appId}/public/data/app_metadata/total_files_converted`);
                        await setDoc(convertedCountDocRef, { count: increment(1) }, { merge: true });
                    }

                } catch (error) {
                    console.error("Error during canvas image processing for", fileToProcess.displayFileName, ":", error);
                    imageDimensions = { width: null, height: null }; // Reset dimensions on error
                    compressedDataUrl = null; // Ensure null if generation failed
                    simulatedCompressedSize = null; // Ensure null on error
                    currentFileStatus = 'error';
                } finally {
                    // Final state update for the file
                    setUploadedFiles(prevFiles =>
                        prevFiles.map(f =>
                            f.id === fileToProcess.id ? { ...f, status: currentFileStatus, compressedSize: simulatedCompressedSize, compressedPreviewUrl: compressedDataUrl, dimensions: imageDimensions } : f
                        )
                    );
                }
            }, [compressionQuality, db, outputFormat]); // Added outputFormat to dependencies

            // Effect to manage the processing queue
            useEffect(() => {
                const uploadedButNotProcessedFiles = uploadedFiles.filter(f => f.status === 'uploaded');
                const pendingFiles = uploadedFiles.filter(f => f.status === 'pending');
                const processingFiles = uploadedFiles.filter(f => f.status === 'processing');

                // If no files are pending and no files are processing, then overall processing is done
                if (uploadedButNotProcessedFiles.length === 0 && pendingFiles.length === 0 && processingFiles.length === 0 && isProcessing) {
                    setIsProcessing(false);
                    console.log("All files processed!");
                }

                // If there are pending files and we have capacity, start processing
                // Prioritize files explicitly marked 'pending' by the compress button
                if (pendingFiles.length > 0 && processingFiles.length < MAX_CONCURRENT_PROCESSES) {
                    setIsProcessing(true); // Indicate that processing is ongoing
                    const nextFile = pendingFiles[0]; // Take the first pending file
                    processFile(nextFile); // Start processing it
                }
            }, [uploadedFiles, isProcessing, processFile, MAX_CONCURRENT_PROCESSES]);

            // Clean up object URLs when component unmounts or files change
            useEffect(() => {
                return () => {
                    uploadedFiles.forEach(file => {
                        URL.revokeObjectURL(file.previewUrl);
                        // compressedPreviewUrl is a data URL, so no revocation needed here.
                    });
                };
            }, [uploadedFiles]);

            // Handler for the main Compress button
            const handleCompressButtonClick = () => {
                if (uploadedFiles.length === 0) {
                    alert('Please upload an image first.');
                    return;
                }

                // Set compressionInitiated to true when the button is pressed
                setCompressionInitiated(true);

                // Revert accent color back to default blue once compress button is pressed
                setDominantAccentColor({ hex: '#4A90E2', rgb: '74, 144, 226' });
                setCssAccentColors('#4A90E2', '74, 144, 226');

                // Reset status of all files to 'pending' if they are not already
                setUploadedFiles(prevFiles =>
                    prevFiles.map(f => {
                        // Only change 'uploaded' or 'completed'/'error' files to 'pending'
                        if (f.status === 'uploaded' || f.status === 'completed' || f.status === 'error') {
                            return { ...f, status: 'pending', compressedSize: null, compressedPreviewUrl: null };
                        }
                        return f;
                    })
                );
            };

            // New: Handle Reset button click
            const handleReset = useCallback(() => {
                // Revoke all existing object URLs to free memory
                uploadedFiles.forEach(file => {
                    URL.revokeObjectURL(file.previewUrl);
                    // No need to revoke compressedPreviewUrl here as it's a data URL.
                });
                setUploadedFiles([]);
                setIsProcessing(false);
                setCompressionQuality(0); // Reset quality to default (0% compression)
                setCompressionInitiated(false); // Reset compression initiated state
                setDominantAccentColor({ hex: '#4A90E2', rgb: '74, 144, 226' }); // Reset accent color to default blue
                setCssAccentColors('#4A90E2', '74, 144, 226'); // Ensure CSS variables are reset
                setCurrentOriginalFileSize(null); // Reset file size display
                setEstimatedCompressedSize(null); // Reset estimated compressed size
                setCompressionMode('quality'); // Reset to default quality mode
                setTargetFileSizeInBytes(0); // Reset target file size in bytes
                setOutputFormat('image/jpeg'); // Reset output format
                console.log("App state reset.");
            }, [uploadedFiles, setCssAccentColors]);

            // New: Handle individual image removal
            const handleRemoveImage = useCallback((idToRemove) => {
                setUploadedFiles(prevFiles => {
                    const fileToRemove = prevFiles.find(f => f.id === idToRemove);
                    if (fileToRemove) {
                        URL.revokeObjectURL(fileToRemove.previewUrl);
                    }
                    const updatedFiles = prevFiles.filter(f => f.id !== idToRemove);
                    
                    // If no files left, reset to default accent color and file size
                    if (updatedFiles.length === 0) {
                        setDominantAccentColor({ hex: '#4A90E2', rgb: '74, 144, 226' });
                        setCssAccentColors('#4A90E2', '74, 144, 226');
                        setCurrentOriginalFileSize(null);
                        setEstimatedCompressedSize(null);
                        setTargetFileSizeInBytes(0);
                    } else {
                        // Update currentOriginalFileSize and estimatedCompressedSize to the new first file
                        const newFirstFileOriginalSize = updatedFiles[0].originalSize;
                        setCurrentOriginalFileSize(newFirstFileOriginalSize);
                        if (compressionMode === 'quality') {
                            setEstimatedCompressedSize(calculateEstimatedCompressedSize(newFirstFileOriginalSize, compressionQuality));
                        } else { // filesize mode
                            // Recalculate targetFileSizeInBytes relative to the new first image's size
                            const newTargetSize = newFirstFileOriginalSize * (targetFileSizeInBytes / (currentOriginalFileSize || 1));
                            setTargetFileSizeInBytes(newTargetSize);
                            const userCompPercent = estimateUserCompressionPercentageFromTargetSize(newFirstFileOriginalSize, newTargetSize);
                            setCompressionQuality(userCompPercent);
                            setEstimatedCompressedSize(newTargetSize);
                        }

                        // If there are still uploaded files but compression hasn't been initiated, keep the "call to action" color
                        if (!compressionInitiated) {
                            setDominantAccentColor({ hex: '#FFD700', rgb: '255, 215, 0' });
                            setCssAccentColors('#FFD700', '255, 215, 0');
                        }
                    }
                    return updatedFiles;
                });
            }, [setCssAccentColors, compressionInitiated, compressionMode, compressionQuality, targetFileSizeInBytes, currentOriginalFileSize, calculateEstimatedCompressedSize, estimateUserCompressionPercentageFromTargetSize]);


            // Handle opening the zoom modal (still useful for original image)
            const openZoomModal = useCallback((url, name, type) => {
                setZoomedImage({ url, name, type });
            }, []);

            // Handle closing the zoom modal
            const closeZoomModal = useCallback(() => {
                setZoomedImage(null);
            }, []);

            // Function to handle download via button click
            const handleDownload = useCallback((url, fileName) => {
                const a = document.createElement('a');
                a.href = url;
                // Determine file extension based on outputFormat
                let fileExtension = 'jpg';
                if (outputFormat === 'image/png') fileExtension = 'png';
                if (outputFormat === 'image/webp') fileExtension = 'webp';

                a.download = `${fileName.replace(/\.(jpeg|jpg|png|webp)$/i, '')}_compressed.${fileExtension}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }, [outputFormat]);

            // Determine if the compress button should be disabled
            const canStartCompression = uploadedFiles.filter(f => f.status === 'uploaded' || f.status === 'completed' || f.status === 'error').length > 0 && !isProcessing;

            // Function to get status color and icon
            const getStatusClasses = (status) => {
                switch (status) {
                    case 'uploaded':
                        return 'text-amber-300'; // Gold-like color for uploaded
                    case 'pending':
                        return 'text-gray-400';
                    case 'processing':
                        return 'text-yellow-500 animate-pulse';
                    case 'completed':
                        return 'text-green-400';
                    case 'error':
                        return 'text-red-400';
                    default:
                        return 'text-gray-400';
                }
            };

            const getStatusIcon = (status) => {
                switch (status) {
                    case 'uploaded':
                        return '✨'; // Sparkles for uploaded
                    case 'pending':
                        return '⏳'; // Hourglass
                    case 'processing':
                        return '🔄'; // Arrows clockwise
                    case 'completed':
                        return '✅'; // Check mark button
                    case 'error':
                        return '❌'; // Cross mark
                    default:
                        return '';
                }
            };

            // Firebase Initialization and Authentication
            useEffect(() => {
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
                const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

                if (!firebaseConfig || Object.keys(firebaseConfig).length === 0) {
                    console.error("Firebase config is missing or empty. Cannot initialize Firebase.");
                    return;
                }

                try {
                    const app = initializeApp(firebaseConfig);
                    const authInstance = getAuth(app);
                    const firestoreInstance = getFirestore(app);

                    setDb(firestoreInstance);
                    setAuth(authInstance);

                    // Sign in with custom token if available, otherwise anonymously
                    const unsubscribe = onAuthStateChanged(authInstance, async (user) => {
                        if (!user) {
                            try {
                                if (initialAuthToken) {
                                    await signInWithCustomToken(authInstance, initialAuthToken);
                                } else {
                                    await signInAnonymously(authInstance);
                                }
                                console.log("Firebase authentication successful.");
                            } catch (error) {
                                console.error("Firebase authentication failed:", error);
                            }
                        }
                        // Set userId from auth.currentUser.uid or generate a new UUID for anonymous users
                        const currentUserId = authInstance.currentUser?.uid || crypto.randomUUID();
                        setUserId(currentUserId);
                        setIsAuthReady(true); // Mark auth as ready

                        // Check if this unique user has been counted before (persistently)
                        const hasVisitedKey = `visited_${appId}_${currentUserId}`;
                        if (!localStorage.getItem(hasVisitedKey)) {
                            const visitorCountDocRef = doc(firestoreInstance, `artifacts/${appId}/public/data/app_metadata/visitor_count`);
                            setDoc(visitorCountDocRef, { count: increment(1) }, { merge: true })
                                .then(() => {
                                    console.log("Visitor count incremented successfully.");
                                    localStorage.setItem(hasVisitedKey, 'true'); // Mark as visited persistently
                                })
                                .catch(error => {
                                    console.error("Error incrementing visitor count:", error);
                                });
                        }
                    });

                    return () => unsubscribe(); // Cleanup auth listener
                } catch (error) {
                    console.error("Error initializing Firebase:", error);
                }
            }, []); // Run only once on component mount

            // Visitor Counter Listener (real-time updates)
            useEffect(() => {
                if (db && isAuthReady) {
                    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                    const visitorCountDocRef = doc(db, `artifacts/${appId}/public/data/app_metadata/visitor_count`);

                    const unsubscribe = onSnapshot(visitorCountDocRef, (docSnap) => {
                        if (docSnap.exists()) {
                            setVisitorCount(docSnap.data().count || 0);
                        } else {
                            setVisitorCount(0); // Document doesn't exist yet
                        }
                    }, (error) => {
                        console.error("Error listening to visitor count:", error);
                    });

                    return () => unsubscribe(); // Cleanup snapshot listener
                }
            }, [db, isAuthReady]); // Re-run when db or isAuthReady changes

            // Total Files Converted Counter Logic
            useEffect(() => {
                if (db && isAuthReady) {
                    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                    const convertedCountDocRef = doc(db, `artifacts/${appId}/public/data/app_metadata/total_files_converted`);

                    // Listen for real-time updates to the total files converted count
                    const unsubscribe = onSnapshot(convertedCountDocRef, (docSnap) => {
                        if (docSnap.exists()) {
                            setTotalFilesConverted(docSnap.data().count || 0);
                        } else {
                            setTotalFilesConverted(0); // Document doesn't exist yet
                        }
                    }, (error) => {
                        console.error("Error listening to total files converted count:", error);
                    });

                    return () => unsubscribe(); // Cleanup snapshot listener
                }
            }, [db, isAuthReady]); // Re-run when db or isAuthReady changes


            return (
                <div className="min-h-screen flex flex-col items-center p-4 sm:p-6 lg:p-8 font-montserrat text-gray-200">
                    {/* Logo */}
                    <div className="absolute top-4 left-4 text-2xl font-bold z-50">
                        <span className="logo-text">JPEG</span>
                    </div>

                    {/* Top AdSense Ad Unit - Conditionally rendered */}
                    {compressionInitiated && (
                        <div className="w-full max-w-full mx-auto mb-8 p-4 bg-[#1A1A2E] rounded-xl shadow-lg text-center border border-[#2A2A4A] max-h-24 overflow-hidden opacity-60">
                            <p className="text-xs italic text-gray-500 mb-1">Advertisement</p>
                            <AdSenseAd client="ca-pub-XXXXXXXXXXXXXXXX" slot="XXXXXXXXXX" key={Date.now()} />
                        </div>
                    )}

                    {/* Main Content and Side Ads Wrapper */}
                    <div className="flex flex-col lg:flex-row lg:items-start lg:justify-center w-full max-w-6xl gap-8">
                        {/* Left AdSense Ad Unit */}
                        {compressionInitiated && (
                            <div className="hidden lg:block w-full lg:w-1/4 max-w-xs p-4 bg-[#1A1A2E] rounded-xl shadow-lg text-center border border-[#2A2A4A] max-h-full overflow-hidden opacity-60">
                                <p className="text-xs italic text-gray-500 mb-1">Advertisement</p>
                                <AdSenseAd client="ca-pub-XXXXXXXXXXXXXXXX" slot="XXXXXXXXXX" key={Date.now() + 1} />
                            </div>
                        )}

                        {/* Main App Content */}
                        <div
                            className="bg-[#1A1A2E] rounded-xl shadow-2xl p-6 sm:p-8 md:p-10 w-full lg:w-3/4 max-w-5xl text-center border-2 transition-all duration-500 ease-out"
                            style={{ borderColor: dominantAccentColor.hex }}
                        >
                            <h1 className="text-3xl sm:text-4xl lg:text-5xl app-title mb-6 drop-shadow-lg"
                                style={{ background: `linear-gradient(to right, #00F0FF, #FF00FF, #FFFF00)`, WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent' }}>
                                JPEG Image Compressor
                            </h1>

                            {/* Drag and Drop Area */}
                            <div
                                className={`
                                    border-4 border-dashed rounded-xl p-8 sm:p-12 mb-8 cursor-pointer transition-all duration-300 ease-in-out
                                    ${isDragging
                                        ? 'bg-[#2A1A0A] shadow-lg text-gray-100'
                                        : 'bg-[#2A2A4A] text-gray-300 hover:bg-[#3A3A5A]'}
                                `}
                                style={{ borderColor: isDragging ? dominantAccentColor.hex : '#4A4A6A' }}
                                onDragEnter={handleDragEnter}
                                onDragLeave={handleDragLeave}
                                onDragOver={handleDragOver}
                                onDrop={handleDrop}
                                onClick={handleDropAreaClick}
                            >
                                <p className="text-lg sm:text-xl">
                                    Drag & Drop JPEG, PNG, or WebP images here, or click to select files
                                </p>
                                <p className="text-sm mt-2">
                                    (Max file size: {MAX_FILE_SIZE_MB} MB per image)
                                </p>
                                <input
                                    type="file"
                                    ref={fileInputRef}
                                    accept="image/jpeg,image/png,image/webp"
                                    multiple
                                    onChange={handleFileInputChange}
                                    className="hidden"
                                />
                            </div>

                            {/* Compression Settings */}
                            <div className="mb-8 p-4 bg-[#2A2A4A] rounded-lg border border-[#4A4A6A]">
                                {/* Output Format Selection */}
                                <div className="mb-4">
                                    <span className="block text-lg font-semibold text-gray-200 mb-2">Output Format:</span>
                                    <div className="flex justify-center space-x-2">
                                        <button
                                            onClick={() => handleOutputFormatChange('image/jpeg')}
                                            className={`px-4 py-2 rounded-lg text-sm font-semibold transition-colors duration-200
                                                ${outputFormat === 'image/jpeg' ? 'bg-[var(--accent-color)] text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}
                                        >
                                            JPEG
                                        </button>
                                        <button
                                            onClick={() => handleOutputFormatChange('image/png')}
                                            className={`px-4 py-2 rounded-lg text-sm font-semibold transition-colors duration-200
                                                ${outputFormat === 'image/png' ? 'bg-[var(--accent-color)] text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}
                                        >
                                            PNG
                                        </button>
                                        <button
                                            onClick={() => handleOutputFormatChange('image/webp')}
                                            className={`px-4 py-2 rounded-lg text-sm font-semibold transition-colors duration-200
                                                ${outputFormat === 'image/webp' ? 'bg-[var(--accent-color)] text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}
                                        >
                                            WebP
                                        </button>
                                    </div>
                                </div>

                                {/* Toggle between Quality and File Size modes */}
                                <div className="flex justify-center mb-4">
                                    <button
                                        onClick={() => setCompressionMode('quality')}
                                        className={`px-4 py-2 rounded-l-lg text-sm font-semibold transition-colors duration-200
                                            ${compressionMode === 'quality' ? 'bg-[var(--accent-color)] text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}
                                    >
                                        Adjust by Quality
                                    </button>
                                    <button
                                        onClick={() => setCompressionMode('filesize')}
                                        className={`px-4 py-2 rounded-r-lg text-sm font-semibold transition-colors duration-200
                                            ${compressionMode === 'filesize' ? 'bg-[var(--accent-color)] text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}
                                        disabled={currentOriginalFileSize === null}
                                    >
                                        Adjust by File Size
                                    </button>
                                </div>

                                <label htmlFor="quality-slider" className="block text-lg font-semibold text-gray-200 mb-3">
                                    {compressionMode === 'quality' ? (
                                        <>
                                            Compression Percentage: <span style={{ color: dominantAccentColor.hex }}>{compressionQuality}%</span>
                                        </>
                                    ) : (
                                        <>
                                            Target File Size: <span style={{ color: dominantAccentColor.hex }}>{currentOriginalFileSize ? formatBytes(targetFileSizeInBytes) : 'N/A'}</span>
                                        </>
                                    )}
                                </label>
                                <input
                                    type="range"
                                    id="quality-slider"
                                    min={compressionMode === 'quality' ? "0" : (currentOriginalFileSize ? Math.round(currentOriginalFileSize * 0.05) : "0")} /* 0% compression to 100% compression */
                                    max={compressionMode === 'quality' ? "100" : (currentOriginalFileSize ? currentOriginalFileSize : "100")} /* 100% compression */
                                    step={compressionMode === 'quality' ? "1" : (currentOriginalFileSize ? Math.max(1, Math.round(currentOriginalFileSize * 0.005)) : "1")} /* 1% for quality, dynamic for size */
                                    value={compressionMode === 'quality' ? compressionQuality : targetFileSizeInBytes}
                                    onChange={handleSliderChange}
                                    className="w-full h-2 bg-[#4A4A6A] rounded-lg appearance-none cursor-pointer"
                                    style={{ accentColor: dominantAccentColor.hex }}
                                />
                                <div className="flex justify-between text-sm text-gray-400 mt-2 px-1">
                                    <span>{compressionMode === 'quality' ? 'Less Compression (0%)' : 'Smaller File (5%)'}</span>
                                    <span>{compressionMode === 'quality' ? 'More Compression (100%)' : 'Larger File (100%)'}</span>
                                </div>

                                {/* File size information */}
                                {currentOriginalFileSize !== null && (
                                    <div className="text-sm text-gray-400 mt-4 px-1">
                                        <p className="mb-1">Original file size: {formatBytes(currentOriginalFileSize)}</p>
                                        {compressionMode === 'quality' && estimatedCompressedSize !== null && (
                                            <p style={{ color: dominantAccentColor.hex }}>
                                                Estimated Compressed file size: {formatBytes(estimatedCompressedSize)}
                                            </p>
                                        )}
                                        {compressionMode === 'filesize' && estimatedCompressedSize !== null && (
                                            <p style={{ color: dominantAccentColor.hex }}>
                                                Estimated Quality: {estimateUserCompressionPercentageFromTargetSize(currentOriginalFileSize, estimatedCompressedSize)}% Compression
                                            </p>
                                        )}
                                    </div>
                                )}
                            </div>

                            {/* Image Previews with Status and Comparison */}
                            {uploadedFiles.length > 0 && (
                                <div className="mb-8 p-4 border border-[#4A4A6A] rounded-lg bg-[#2A2A4A] max-h-[80vh] overflow-y-auto grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6 shadow-inner justify-items-center">
                                    {uploadedFiles.map((item) => (
                                        <div key={item.id} className="relative flex flex-col items-center p-3 border-2 rounded-xl bg-gradient-to-br from-[#3A3A5A] to-[#2A2A4A] shadow-xl transform hover:scale-105 hover:shadow-2xl transition-all duration-300 ease-in-out"
                                            style={{ borderColor: dominantAccentColor.hex, '--tw-shadow-color': dominantAccentColor.hex, boxShadow: `0 0 10px rgba(${dominantAccentColor.rgb}, 0.5)` }}>
                                            {/* Remove Button */}
                                            <button
                                                onClick={() => handleRemoveImage(item.id)}
                                                className="absolute top-2 right-2 bg-red-700 text-white rounded-full h-6 w-6 flex items-center justify-center text-sm font-bold hover:bg-red-800 transition-colors duration-200"
                                                title="Remove image"
                                            >
                                                &times;
                                            </button>

                                            <p className={`text-sm font-medium ${getStatusClasses(item.status)} mb-2`}>
                                                {getStatusIcon(item.status)} {item.status.charAt(0).toUpperCase() + item.status.slice(1)}
                                            </p>
                                            <p className="text-sm text-gray-200 truncate w-full px-1 mb-2 font-semibold">{item.displayFileName}</p> {/* Changed to displayFileName */}
                                            {item.dimensions.width && item.dimensions.height && (
                                                <p className="text-xs text-gray-400 mb-2">
                                                    {item.dimensions.width}x{item.dimensions.height} px
                                                </p>
                                            )}

                                            <div className="flex flex-col sm:flex-row justify-around w-full gap-2"> {/* Changed to flex-col for better stacking */}
                                                {/* Original Image */}
                                                <div className="flex flex-col items-center w-full sm:w-1/2 mb-4 sm:mb-0"> {/* Added margin-bottom for spacing */}
                                                    <p className="text-xs text-gray-400 mb-1">Original</p>
                                                    <img
                                                        src={item.previewUrl}
                                                        alt={`Original ${item.displayFileName}`}
                                                        className="w-40 h-40 object-cover rounded-md border border-[#4A4A6A] cursor-pointer shadow-md"
                                                        onClick={() => openZoomModal(item.previewUrl, item.displayFileName, 'original')}
                                                    />
                                                    <p className="text-xs text-gray-300 mt-1">{formatBytes(item.originalSize)}</p>
                                                </div>

                                                {/* Compressed File Info & Download - Conditionally rendered */}
                                                {/* This entire div is only rendered if compressionInitiated is true */}
                                                {compressionInitiated && (
                                                    <div className="flex flex-col items-center w-full sm:w-1/2">
                                                        {item.status === 'completed' && item.compressedSize !== null && item.compressedPreviewUrl !== null ? (
                                                            <>
                                                                <p className="text-xs text-gray-400 mb-1">Compressed</p>
                                                                <img
                                                                    src={item.compressedPreviewUrl}
                                                                    alt={`Compressed ${item.displayFileName}`}
                                                                    className="w-40 h-40 object-cover rounded-md border border-[#4A4A6A] cursor-pointer shadow-md"
                                                                    onClick={() => openZoomModal(item.compressedPreviewUrl, item.displayFileName, 'compressed')}
                                                                />
                                                                <p className="text-xs text-green-400 font-bold mt-1">Saved: {(((item.originalSize - item.compressedSize) / item.originalSize) * 100).toFixed(0)}%</p>
                                                                <p className="text-xs font-semibold mt-1" style={{ color: dominantAccentColor.hex }}>
                                                                    Quality: {compressionQuality}%
                                                                </p>
                                                                <button
                                                                    onClick={() => handleDownload(item.compressedPreviewUrl, item.originalFileName)}
                                                                    className="mt-2 inline-flex items-center px-3 py-1.5 border border-transparent text-xs font-medium rounded-md shadow-sm text-white bg-gradient-to-r from-[var(--accent-color)] to-[var(--accent-color-dark)] hover:from-[var(--accent-color-dark)] hover:to-[var(--accent-color)] focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-[var(--accent-color)] transition-all duration-200 ease-in-out transform hover:scale-105"
                                                                >
                                                                    Download Compressed File
                                                                </button>
                                                            </>
                                                        ) : item.status === 'error' ? (
                                                            <div className="w-full h-full flex flex-col items-center justify-center text-red-500 text-center text-xs">
                                                                <p>Error processing.</p>
                                                                <div className="w-40 h-40 flex items-center justify-center text-gray-500 border border-[#4A4A6A] rounded-md mt-1">
                                                                    <span className="text-3xl">🚫</span>
                                                                </div>
                                                            </div>
                                                        ) : ( /* Shows placeholder for 'uploaded', 'pending', 'processing' states AFTER compression is initiated */
                                                            <div className="w-full h-full flex flex-col items-center justify-center">
                                                                <p className="text-xs text-gray-400 mb-1">Compressed</p>
                                                                <div className="w-40 h-40 flex items-center justify-center text-gray-500 border border-[#4A4A6A] rounded-md">
                                                                    {item.status === 'processing' ? (
                                                                        <span className="w-8 h-8 border-4 border-[#FFD700] border-t-transparent rounded-full animate-spin-slow"></span>
                                                                    ) : (
                                                                        <span className="text-3xl">⏳</span>
                                                                    )}
                                                                </div>
                                                            </div>
                                                        )}
                                                    </div >
                                                )}
                                            </div >
                                        </div >
                                    ))}
                                </div >
                            )}

                            {/* Processing Status Message */}
                            {isProcessing && (
                                <p className="text-lg text-[#FFD700] font-semibold mb-4 flex items-center justify-center gap-2">
                                    <span className="w-5 h-5 border-2 border-[#FFD700] border-t-transparent rounded-full animate-spin-slow"></span>
                                    Processing images... Please wait.
                                </p>
                            )}

                            {/* Buttons */}
                            <div className="flex flex-col sm:flex-row justify-center gap-4 mt-8">
                                <button
                                    onClick={handleCompressButtonClick}
                                    disabled={!canStartCompression}
                                    className={`
                                        py-3 px-8 rounded-lg text-lg font-semibold transition-all duration-300 ease-in-out w-full sm:w-auto
                                        ${canStartCompression
                                            ? 'text-white shadow-lg focus:outline-none focus:ring-4 focus:ring-[var(--accent-color)] focus:ring-opacity-75 transform hover:-translate-y-1 animate-pulse-glow'
                                            : 'bg-gray-600 text-gray-400 cursor-not-allowed'}
                                        `}
                                    style={{ background: `linear-gradient(to right, ${dominantAccentColor.hex}, var(--accent-color-dark))` }}
                                >
                                    {isProcessing ? 'Processing...' : 'Compress'}
                                </button>
                                <button
                                    onClick={handleReset}
                                    disabled={uploadedFiles.length === 0 && !isProcessing}
                                    className={`
                                        py-3 px-8 rounded-lg text-lg font-semibold transition-all duration-300 ease-in-out w-full sm:w-auto
                                        ${(uploadedFiles.length > 0 || isProcessing)
                                            ? 'bg-gray-700 text-gray-200 shadow-lg hover:bg-gray-800 focus:outline-none focus:ring-4 focus:ring-gray-500 focus:ring-opacity-75 transform hover:-translate-y-1'
                                            : 'bg-gray-600 text-gray-400 cursor-not-allowed'}
                                        `}
                                >
                                    Reset
                                </button>
                            </div>
                        </div>

                        {/* Right AdSense Ad Unit */}
                        {compressionInitiated && (
                            <div className="hidden lg:block w-full lg:w-1/4 max-w-xs p-4 bg-[#1A1A2E] rounded-xl shadow-lg text-center border border-[#2A2A4A] max-h-full overflow-hidden opacity-60">
                                <p className="text-xs italic text-gray-500 mb-1">Advertisement</p>
                                <AdSenseAd client="ca-pub-XXXXXXXXXXXXXXXX" slot="XXXXXXXXXX" key={Date.now() + 2} />
                            </div>
                        )}
                    </div> {/* End of Main Content and Side Ads Wrapper */}

                    {/* Bottom AdSense Ad Unit - Conditionally rendered */}
                    {compressionInitiated && (
                        <div className="mt-8 w-full max-w-full mx-auto p-4 bg-[#1A1A2E] rounded-xl shadow-lg text-center border border-[#2A2A4A] max-h-24 overflow-hidden opacity-60">
                            <p className="text-xs italic text-gray-500 mb-1">Advertisement</p>
                            <AdSenseAd client="ca-pub-XXXXXXXXXXXXXXXX" slot="XXXXXXXXXX" key={Date.now() + 3} />
                        </div>
                    )}

                    {/* Visitor and Files Converted Counter at bottom-left */}
                    <div className="fixed bottom-4 left-4 p-4 bg-[#2A2A4A] rounded-lg shadow-xl text-gray-200 text-sm border-2 border-[#5A5A7A] z-40">
                        <p className="font-semibold mb-1">Total Visitors: <span className="text-[#FFD700]">{visitorCount}</span></p>
                        <p className="font-semibold">Files Converted: <span className="text-[#32CD32]">{totalFilesConverted}</span></p>
                        {userId && (
                            <p className="text-xs text-gray-500 mt-2 break-all">Your User ID: {userId}</p>
                        )}
                    </div>

                    {/* Zoom Modal */}
                    {zoomedImage && (
                        <div
                            className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50"
                            onClick={closeZoomModal} // Close when clicking outside image
                        >
                            <div className="bg-[#1A1A2E] rounded-lg p-4 max-w-3xl max-h-[90vh] overflow-auto relative" onClick={(e) => e.stopPropagation()}>
                                <button
                                    onClick={closeZoomModal}
                                    className="absolute top-2 right-2 bg-red-700 text-white rounded-full h-8 w-8 flex items-center justify-center text-xl font-bold hover:bg-red-800 transition-colors duration-200 z-10"
                                    title="Close"
                                >
                                    &times;
                                </button>
                                <h3 className="text-lg font-semibold mb-3 text-gray-100">
                                    {zoomedImage.name} ({zoomedImage.type === 'original' ? 'Original' : 'Compressed'})
                                </h3>
                                <img
                                    src={zoomedImage.url}
                                    alt={zoomedImage.name}
                                    className="max-w-full max-h-[75vh] object-contain mx-auto rounded-md border border-[#4A4A6A] shadow-lg"
                                />
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // Use createRoot for React 18
        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<App />);
    </script>
</body>
</html>
