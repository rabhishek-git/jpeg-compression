<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JPEG Image Compressor</title>
    <!-- Google AdSense Script (MUST REPLACE ca-pub-XXXXXXXXXXXXXXXX with your actual Publisher ID) -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXXXXXXXXXXXXX" crossorigin="anonymous"></script>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom styles for range input thumb */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #8B5CF6; /* Tailwind purple-500 */
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.3); /* purple-500 with opacity */
            transition: background .15s ease-in-out, box-shadow .15s ease-in-out;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #8B5CF6; /* Tailwind purple-500 */
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.3); /* purple-500 with opacity */
            transition: background .15s ease-in-out, box-shadow .15s ease-in-out;
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #7C3AED; /* Tailwind purple-600 */
        }
        input[type="range"]::-moz-range-thumb:hover {
            background: #7C3AED; /* Tailwind purple-600 */
        }

        /* Custom CSS for the spinning animation */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .animate-spin-slow {
            animation: spin 1.5s linear infinite;
        }

        /* New CSS for continuous button animation */
        @keyframes pulse-glow {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.7); /* purple-500 with opacity */
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 0 8px rgba(139, 92, 246, 0); /* transparent */
                transform: scale(1.02);
            }
        }
        .animate-pulse-glow {
            animation: pulse-glow 2s infinite ease-in-out;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <!-- React and ReactDOM CDN -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel for JSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
        // Destructure React hooks from the global React object
        const { useState, useCallback, useEffect, useRef } = React;

        // AdSense Ad Component
        const AdSenseAd = ({ client, slot, format = 'auto', responsive = true }) => {
            const adRef = useRef(null); // Ref to the ins element

            useEffect(() => {
                const loadAd = () => {
                    try {
                        // Only push if the element has a width and adsbygoogle is available
                        if (adRef.current && adRef.current.offsetWidth > 0 && window.adsbygoogle) {
                            (window.adsbygoogle = window.adsbygoogle || []).push({});
                        } else if (!window.adsbygoogle) {
                            console.warn('adsbygoogle not found. AdSense might not load.');
                        }
                    } catch (e) {
                        console.error('Error pushing AdSense ad:', e);
                    }
                };

                // Use a setTimeout to ensure the DOM has rendered and calculated dimensions
                const timer = setTimeout(loadAd, 100); // Small delay

                // Add a listener for window resize to try loading ads again
                window.addEventListener('resize', loadAd);

                return () => {
                    clearTimeout(timer);
                    window.removeEventListener('resize', loadAd);
                };
            }, [client, slot]); // Re-run effect if client or slot changes (though unlikely for static ads)

            return (
                <ins className="adsbygoogle"
                    ref={adRef} // Attach ref to the ins element
                    style={{ display: 'block', textAlign: 'center' }} // Centered display
                    data-ad-client={client}
                    data-ad-slot={slot}
                    data-ad-format={format}
                    data-full-width-responsive={responsive ? 'true' : 'false'}
                ></ins>
            );
        };


        // Main App component
        const App = () => {
            // uploadedFiles now includes 'status', 'originalSize', 'compressedSize', and 'compressedPreviewUrl' properties
            const [uploadedFiles, setUploadedFiles] = useState([]);
            const [isDragging, setIsDragging] = useState(false);
            const fileInputRef = useRef(null);
            const [compressionQuality, setCompressionQuality] = useState(80);
            // State to track if any files are currently being "processed"
            const [isProcessing, setIsProcessing] = useState(false);
            // New state for the zoomed image: { url: string, name: string, type: 'original' | 'compressed' }
            const [zoomedImage, setZoomedImage] = useState(null);
            // Removed: New state for LLM compression advice and loading status
            // const [compressionAdvice, setCompressionAdvice] = useState('');
            // const [gettingAdvice, setGettingAdvice] = useState(false);
            // NEW: State to track if compression has been initiated at least once
            const [compressionInitiated, setCompressionInitiated] = useState(false);


            // Max number of files to "process" concurrently (simulated)
            const MAX_CONCURRENT_PROCESSES = 3;
            // New: Maximum allowed file size in MB
            const MAX_FILE_SIZE_MB = 10;
            const MAX_FILE_SIZE_BYTES = MAX_FILE_SIZE_MB * 1024 * 1024; // Convert MB to Bytes

            // Helper to format file size
            const formatBytes = (bytes, decimals = 2) => {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const dm = decimals < 0 ? 0 : decimals;
                const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
            };

            // Handle files dropped or selected via input
            const handleFiles = useCallback((files) => {
                const newValidFiles = [];
                const warnings = [];
                let imageCounter = uploadedFiles.length; // Start counter from current number of files

                Array.from(files).forEach(file => {
                    if (file.type !== 'image/jpeg') {
                        warnings.push(`"${file.name}" is not a JPEG image and will be skipped.`);
                    } else if (file.size > MAX_FILE_SIZE_BYTES) {
                        warnings.push(`"${file.name}" (${formatBytes(file.size)}) exceeds the ${MAX_FILE_SIZE_MB} MB limit and will be skipped.`);
                    } else {
                        imageCounter++;
                        newValidFiles.push({
                            id: file.name + '-' + file.size + '-' + Date.now(), // Unique ID for keying and tracking
                            originalFileName: file.name, // Store original file name
                            displayFileName: `Image ${imageCounter}`, // New: Display name for the image
                            file,
                            previewUrl: URL.createObjectURL(file),
                            status: 'pending', // Initial status
                            originalSize: file.size, // Store original size
                            compressedSize: null, // Will be set after "compression"
                            compressedPreviewUrl: null, // Will be set after "compression"
                            dimensions: { width: null, height: null }, // New: Store image dimensions
                        });
                    }
                });

                if (warnings.length > 0) {
                    // Use a custom modal in a production app instead of alert
                    alert('Some files were skipped:\n' + warnings.join('\n'));
                }

                setUploadedFiles(prevFiles => [...prevFiles, ...newValidFiles]);
                setCompressionInitiated(false); // Reset compression initiated state on new file uploads
            }, [MAX_FILE_SIZE_BYTES, MAX_FILE_SIZE_MB, uploadedFiles.length]); // Add uploadedFiles.length to dependencies

            // Drag event handlers
            const handleDragEnter = useCallback((e) => {
                e.preventDefault();
                e.stopPropagation();
                setIsDragging(true);
            }, []);

            const handleDragLeave = useCallback((e) => {
                e.preventDefault();
                e.stopPropagation();
                if (!e.currentTarget.contains(e.relatedTarget)) {
                    setIsDragging(false);
                }
            }, []);

            const handleDragOver = useCallback((e) => {
                e.preventDefault();
                e.stopPropagation();
                setIsDragging(true);
            }, []);

            const handleDrop = useCallback((e) => {
                e.preventDefault();
                e.stopPropagation();
                setIsDragging(false);
                if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                    handleFiles(e.dataTransfer.files);
                    e.dataTransfer.clearData();
                }
            }, [handleFiles]);

            // Handle file input change
            const handleFileInputChange = useCallback((e) => {
                if (e.target.files && e.target.files.length > 0) {
                    handleFiles(e.target.files);
                    e.target.value = null; // Clear input value to allow re-uploading same files
                }
            }, [handleFiles]);

            // Trigger file input click when drop area is clicked
            const handleDropAreaClick = useCallback(() => {
                fileInputRef.current?.click();
            }, []);

            // Handle quality slider change
            const handleQualityChange = useCallback((e) => {
                setCompressionQuality(Number(e.target.value));
            }, []);

            // Function to simulate processing a single file
            const processFile = useCallback(async (fileToProcess) => {
                let currentFileStatus = 'processing'; // Default to processing initially
                setUploadedFiles(prevFiles =>
                    prevFiles.map(f =>
                        f.id === fileToProcess.id ? { ...f, status: currentFileStatus } : f
                    )
                );

                console.log(`Simulating compression for: ${fileToProcess.displayFileName} (Quality: ${compressionQuality}%)`);

                // Simulate network request/backend processing time
                await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 1000)); // 1.5 to 2.5 seconds delay

                let simulatedCompressedSize = null;
                let compressedDataUrl = null;
                let imageDimensions = { width: null, height: null };
                
                try {
                    // Read file as ArrayBuffer to get actual byte size for simulation
                    const arrayBuffer = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsArrayBuffer(fileToProcess.file);
                    });

                    // Simulate compressed size based on quality and original size
                    // This simulation is more realistic with actual file size from ArrayBuffer
                    const originalBytes = arrayBuffer.byteLength;
                    if (compressionQuality <= 50) {
                        simulatedCompressedSize = originalBytes * (0.05 + (compressionQuality / 50) * 0.15); // 5% to 20%
                    } else {
                        simulatedCompressedSize = originalBytes * (0.20 + ((compressionQuality - 50) / 50) * 0.75); // 20% to 95%
                    }
                    simulatedCompressedSize = Math.max(1000, simulatedCompressedSize); // Ensure a minimum size (1KB)


                    // Use FileReader to get Base64 data URL for canvas processing
                    const base64DataUrl = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(fileToProcess.file);
                    });

                    const img = new Image();
                    await Promise.race([
                        new Promise((resolve, reject) => {
                            img.onload = () => {
                                if (img.naturalWidth > 0 && img.naturalHeight > 0) {
                                    imageDimensions = { width: img.naturalWidth, height: img.naturalHeight };
                                    resolve();
                                } else {
                                    reject(new Error("Image loaded with invalid dimensions."));
                                }
                            };
                            img.onerror = () => {
                                console.error("Image failed to load for canvas processing (onerror):", fileToProcess.displayFileName);
                                reject(new Error("Image load error"));
                            };
                            img.src = base64DataUrl; // Use the Base64 data URL
                        }),
                        new Promise((_, reject) =>
                            setTimeout(() => reject(new Error("Image load timeout")), 5000)
                        )
                    ]);

                    await img.decode(); // Ensure image is fully decoded

                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.naturalWidth;
                    canvas.height = img.naturalHeight;
                    ctx.drawImage(img, 0, 0);
                    compressedDataUrl = canvas.toDataURL('image/jpeg', compressionQuality / 100);
                    console.log("Generated compressed data URL for download:", compressedDataUrl.substring(0, 50) + "...");
                    currentFileStatus = 'completed';

                } catch (error) {
                    console.error("Error during canvas image processing for", fileToProcess.displayFileName, ":", error);
                    imageDimensions = { width: null, height: null }; // Reset dimensions on error
                    compressedDataUrl = null; // Ensure null if generation failed
                    simulatedCompressedSize = null; // Ensure null on error
                    currentFileStatus = 'error';
                } finally {
                    // Final state update for the file
                    setUploadedFiles(prevFiles =>
                        prevFiles.map(f =>
                            f.id === fileToProcess.id ? { ...f, status: currentFileStatus, compressedSize: simulatedCompressedSize, compressedPreviewUrl: compressedDataUrl, dimensions: imageDimensions } : f
                        )
                    );
                }
            }, [compressionQuality]);

            // Effect to manage the processing queue
            useEffect(() => {
                const pendingFiles = uploadedFiles.filter(f => f.status === 'pending');
                const processingFiles = uploadedFiles.filter(f => f.status === 'processing');

                // If no files are pending and no files are processing, then overall processing is done
                if (pendingFiles.length === 0 && processingFiles.length === 0 && isProcessing) {
                    setIsProcessing(false);
                    console.log("All files processed!");
                }

                // If there are pending files and we have capacity, start processing
                if (pendingFiles.length > 0 && processingFiles.length < MAX_CONCURRENT_PROCESSES) {
                    setIsProcessing(true); // Indicate that processing is ongoing
                    const nextFile = pendingFiles[0]; // Take the first pending file
                    processFile(nextFile); // Start processing it
                }
            }, [uploadedFiles, isProcessing, processFile, MAX_CONCURRENT_PROCESSES]);

            // Clean up object URLs when component unmounts or files change
            useEffect(() => {
                return () => {
                    uploadedFiles.forEach(file => {
                        URL.revokeObjectURL(file.previewUrl);
                        // compressedPreviewUrl is a data URL, so no revocation needed here.
                    });
                };
            }, [uploadedFiles]);

            // Handler for the main Compress button
            const handleCompressButtonClick = () => {
                if (uploadedFiles.length === 0) {
                    alert('Please upload JPEG images first.');
                    return;
                }

                // Set compressionInitiated to true when the button is pressed
                setCompressionInitiated(true);

                // Reset status of all files to 'pending' if they are not already
                setUploadedFiles(prevFiles =>
                    prevFiles.map(f => {
                        if (f.status === 'completed' || f.status === 'error') {
                            return { ...f, status: 'pending', compressedSize: null, compressedPreviewUrl: null }; // Reset description (removed optimalQualityAdvice)
                        }
                        return f;
                    })
                );
            };

            // New: Handle Reset button click
            const handleReset = useCallback(() => {
                // Revoke all existing object URLs to free memory
                uploadedFiles.forEach(file => {
                    URL.revokeObjectURL(file.previewUrl);
                    // No need to revoke compressedPreviewUrl here as it's a data URL.
                });
                setUploadedFiles([]);
                setIsProcessing(false);
                setCompressionQuality(80); // Reset quality to default
                // Removed: setCompressionAdvice(''); // Clear advice
                setCompressionInitiated(false); // Reset compression initiated state
                console.log("App state reset.");
            }, [uploadedFiles]);

            // New: Handle individual image removal
            const handleRemoveImage = useCallback((idToRemove) => {
                setUploadedFiles(prevFiles => {
                    const fileToRemove = prevFiles.find(f => f.id === idToRemove);
                    if (fileToRemove) {
                        URL.revokeObjectURL(fileToRemove.previewUrl);
                        // No need to revoke compressedPreviewUrl here as it's a data URL.
                    }
                    return prevFiles.filter(f => f.id !== idToRemove);
                });
            }, []);

            // Handle opening the zoom modal (still useful for original image)
            const openZoomModal = useCallback((url, name, type) => {
                setZoomedImage({ url, name, type });
            }, []);

            // Handle closing the zoom modal
            const closeZoomModal = useCallback(() => {
                setZoomedImage(null);
            }, []);

            // Gemini API: Get Compression Advice
            // Removed: const getCompressionAdvice = useCallback(async () => { /* ... */ }, []);

            // Determine if the compress button should be disabled
            const canStartCompression = uploadedFiles.filter(f => f.status === 'pending' || f.status === 'completed' || f.status === 'error').length > 0 && !isProcessing;


            // Function to get status color and icon
            const getStatusClasses = (status) => {
                switch (status) {
                    case 'pending':
                        return 'text-gray-500';
                    case 'processing':
                        return 'text-blue-500 animate-pulse';
                    case 'completed':
                        return 'text-green-500';
                    case 'error':
                        return 'text-red-500';
                    default:
                        return 'text-gray-500';
                }
            };

            const getStatusIcon = (status) => {
                switch (status) {
                    case 'pending':
                        return '⏳'; // Hourglass
                    case 'processing':
                        return '🔄'; // Arrows clockwise
                    case 'completed':
                        return '✅'; // Check mark button
                    case 'error':
                        return '❌'; // Cross mark
                    default:
                        return '';
                }
            };

            return (
                <div className="min-h-screen bg-gradient-to-br from-gray-900 via-blue-950 to-gray-800 flex flex-col items-center p-4 sm:p-6 lg:p-8 font-inter">
                    {/* Top AdSense Ad Unit - Conditionally rendered */}
                    {compressionInitiated && (
                        <div className="w-full max-w-full mx-auto mb-8 p-4 bg-gray-900 rounded-xl shadow-lg text-center border border-gray-700 max-h-24 overflow-hidden">
                            <p className="text-sm text-gray-400 mb-2">Advertisement</p>
                            <AdSenseAd client="ca-pub-XXXXXXXXXXXXXXXX" slot="XXXXXXXXXX" key={Date.now()} />
                        </div>
                    )}

                    {/* Main Content and Side Ads Wrapper */}
                    <div className="flex flex-col lg:flex-row lg:items-start lg:justify-center w-full max-w-6xl gap-8">
                        {/* Left AdSense Ad Unit */}
                        {compressionInitiated && (
                            <div className="hidden lg:block w-full lg:w-1/4 max-w-xs p-4 bg-gray-900 rounded-xl shadow-lg text-center border border-gray-700 max-h-full overflow-hidden">
                                <p className="text-sm text-gray-400 mb-2">Advertisement</p>
                                <AdSenseAd client="ca-pub-XXXXXXXXXXXXXXXX" slot="XXXXXXXXXX" key={Date.now() + 1} />
                            </div>
                        )}

                        {/* Main App Content */}
                        <div className="bg-[#1A1A2E] rounded-xl shadow-2xl p-6 sm:p-8 md:p-10 w-full lg:w-3/4 max-w-5xl text-center border border-[#2A2A4A] transform rotate-3 scale-95 transition-transform duration-500 ease-out hover:rotate-0 hover:scale-100">
                            <h1 className="text-3xl sm:text-4xl lg:text-5xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-[#FFD700] via-[#FF8C00] to-[#FF4500] mb-6 drop-shadow-lg">
                                JPEG Image Compressor
                            </h1>

                            {/* Drag and Drop Area */}
                            <div
                                className={`
                                    border-4 border-dashed rounded-xl p-8 sm:p-12 mb-8 cursor-pointer transition-all duration-300 ease-in-out
                                    ${isDragging
                                        ? 'border-[#8A2BE2] bg-[#3A2B5E] shadow-lg text-gray-100'
                                        : 'border-[#4A4A6A] bg-[#2A2A4A] text-gray-300 hover:border-[#6A6A8A] hover:bg-[#3A3A5A]'}
                                `}
                                onDragEnter={handleDragEnter}
                                onDragLeave={handleDragLeave}
                                onDragOver={handleDragOver}
                                onDrop={handleDrop}
                                onClick={handleDropAreaClick}
                            >
                                <p className="text-lg sm:text-xl">
                                    Drag & Drop JPEG images here, or click to select files
                                </p>
                                <p className="text-sm mt-2">
                                    (Max file size: {MAX_FILE_SIZE_MB} MB per image)
                                </p>
                                <input
                                    type="file"
                                    ref={fileInputRef}
                                    accept="image/jpeg"
                                    multiple
                                    onChange={handleFileInputChange}
                                    className="hidden"
                                />
                            </div>

                            {/* Compression Quality Setting */}
                            <div className="mb-8 p-4 bg-[#2A2A4A] rounded-lg border border-[#4A4A6A]">
                                <label htmlFor="quality-slider" className="block text-lg font-semibold text-gray-200 mb-3">
                                    Compression Quality: <span className="text-[#FFD700]">{compressionQuality}%</span>
                                </label>
                                <input
                                    type="range"
                                    id="quality-slider"
                                    min="10"
                                    max="100"
                                    value={compressionQuality}
                                    onChange={handleQualityChange}
                                    className="w-full h-2 bg-[#4A4A6A] rounded-lg appearance-none cursor-pointer accent-[#FFD700]"
                                />
                                <div className="flex justify-between text-sm text-gray-400 mt-2 px-1">
                                    <span>Low (10%)</span>
                                    <span>High (100%)</span>
                                </div>
                                {/* Removed compressionAdvice display */}
                                {/* {compressionAdvice && (
                                    <p className="mt-3 text-sm text-gray-300 italic">{compressionAdvice}</p>
                                )} */}
                            </div>

                            {/* Image Previews with Status and Comparison */}
                            {uploadedFiles.length > 0 && (
                                <div className="mb-8 p-4 border border-[#4A4A6A] rounded-lg bg-[#2A2A4A] max-h-[80vh] overflow-y-auto grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6 shadow-inner justify-items-center">
                                    {uploadedFiles.map((item) => (
                                        <div key={item.id} className="relative flex flex-col items-center p-3 border border-[#4A4A6A] rounded-lg bg-[#3A3A5A] shadow-md transform hover:scale-105 transition-transform duration-200 ease-in-out">
                                            {/* Remove Button */}
                                            <button
                                                onClick={() => handleRemoveImage(item.id)}
                                                className="absolute top-2 right-2 bg-red-600 text-white rounded-full h-6 w-6 flex items-center justify-center text-sm font-bold hover:bg-red-700 transition-colors duration-200"
                                                title="Remove image"
                                            >
                                                &times;
                                            </button>

                                            <p className={`text-sm font-medium ${getStatusClasses(item.status)} mb-2`}>
                                                {getStatusIcon(item.status)} {item.status.charAt(0).toUpperCase() + item.status.slice(1)}
                                            </p>
                                            <p className="text-sm text-gray-200 truncate w-full px-1 mb-2 font-semibold">{item.displayFileName}</p> {/* Changed to displayFileName */}
                                            {item.dimensions.width && item.dimensions.height && (
                                                <p className="text-xs text-gray-400 mb-2">
                                                    {item.dimensions.width}x{item.dimensions.height} px
                                                </p>
                                            )}

                                            <div className="flex justify-around w-full gap-2">
                                                {/* Original Image */}
                                                <div className="flex flex-col items-center w-1/2">
                                                    <p className="text-xs text-gray-400 mb-1">Original</p>
                                                    <img
                                                        src={item.previewUrl}
                                                        alt={`Original ${item.displayFileName}`}
                                                        className="w-24 h-24 object-cover rounded-md border border-[#4A4A6A] cursor-pointer"
                                                        onClick={() => openZoomModal(item.previewUrl, item.displayFileName, 'original')}
                                                    />
                                                    <p className="text-xs text-gray-300 mt-1">{formatBytes(item.originalSize)}</p>
                                                </div>

                                                {/* Compressed File Info & Download - Conditionally rendered */}
                                                {compressionInitiated && (
                                                    <div className="flex flex-col items-center w-1/2">
                                                        {item.status === 'completed' && item.compressedSize !== null && item.compressedPreviewUrl !== null ? (
                                                            <> {/* Added Fragment here */}
                                                                <p className="text-xs text-[#32CD32] font-bold mt-1">{formatBytes(item.compressedSize)}</p>
                                                                <p className="text-xs text-gray-400">
                                                                    Saved: {(((item.originalSize - item.compressedSize) / item.originalSize) * 100).toFixed(0)}%
                                                                </p>
                                                                <p className="text-xs font-semibold text-[#FFD700] mt-1">
                                                                    Quality: {compressionQuality}%
                                                                </p>
                                                                <a
                                                                    href={item.compressedPreviewUrl}
                                                                    download={`compressed_${item.displayFileName}.jpg`}
                                                                    className="mt-2 inline-flex items-center px-3 py-1.5 border border-transparent text-xs font-medium rounded-md shadow-sm text-white bg-[#8A2BE2] hover:bg-[#7D26C9] focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-[#8A2BE2]"
                                                                >
                                                                    Download Compressed File
                                                                </a>
                                                            </>
                                                        ) : item.status === 'error' ? ( // Only show error if status is explicitly error
                                                            <div className="w-full flex flex-col items-center justify-center text-red-500 text-center text-xs">
                                                                Error processing.
                                                            </div>
                                                        ) : (
                                                            // Show nothing for 'pending' or 'processing' states
                                                            <div className="w-full h-full flex items-center justify-center">
                                                                {/* Empty div to maintain layout space if needed, or just null */}
                                                            </div>
                                                        )}
                                                    </div >
                                                )}
                                            </div >
                                        </div >
                                    ))}
                                </div >
                            )}

                            {/* Processing Status Message */}
                            {isProcessing && (
                                <p className="text-lg text-[#FFD700] font-semibold mb-4 flex items-center justify-center gap-2">
                                    <span className="w-5 h-5 border-2 border-[#FFD700] border-t-transparent rounded-full animate-spin-slow"></span>
                                    Processing images... Please wait.
                                </p>
                            )}

                            {/* Buttons */}
                            <div className="flex flex-col sm:flex-row justify-center gap-4 mt-8">
                                {/* Get Compression Advice Button - REMOVED */}
                                <button
                                    onClick={handleCompressButtonClick}
                                    disabled={!canStartCompression}
                                    className={`
                                        py-3 px-8 rounded-lg text-lg font-semibold transition-all duration-300 ease-in-out w-full sm:w-auto
                                        ${canStartCompression
                                            ? 'bg-gradient-to-r from-[#8A2BE2] to-[#4B0082] text-white shadow-lg hover:from-[#7D26C9] hover:to-[#3A0061] focus:outline-none focus:ring-4 focus:ring-[#8A2BE2] focus:ring-opacity-75 transform hover:-translate-y-1 animate-pulse-glow'
                                            : 'bg-gray-600 text-gray-400 cursor-not-allowed'}
                                `}
                                >
                                    {isProcessing ? 'Processing...' : 'Compress'}
                                </button>
                                <button
                                    onClick={handleReset}
                                    disabled={uploadedFiles.length === 0 && !isProcessing}
                                    className={`
                                        py-3 px-8 rounded-lg text-lg font-semibold transition-all duration-300 ease-in-out w-full sm:w-auto
                                        ${(uploadedFiles.length > 0 || isProcessing)
                                            ? 'bg-gray-700 text-white shadow-lg hover:bg-gray-800 focus:outline-none focus:ring-4 focus:ring-gray-500 focus:ring-opacity-75 transform hover:-translate-y-1'
                                            : 'bg-gray-600 text-gray-400 cursor-not-allowed'}
                                `}
                                >
                                    Reset
                                </button>
                            </div>
                        </div>

                        {/* Right AdSense Ad Unit */}
                        {compressionInitiated && (
                            <div className="hidden lg:block w-full lg:w-1/4 max-w-xs p-4 bg-gray-900 rounded-xl shadow-lg text-center border border-gray-700 max-h-full overflow-hidden">
                                <p className="text-sm text-gray-400 mb-2">Advertisement</p>
                                <AdSenseAd client="ca-pub-XXXXXXXXXXXXXXXX" slot="XXXXXXXXXX" key={Date.now() + 2} />
                            </div>
                        )}
                    </div> {/* End of Main Content and Side Ads Wrapper */}

                    {/* Bottom AdSense Ad Unit - Conditionally rendered */}
                    {compressionInitiated && (
                        <div className="mt-8 w-full max-w-full mx-auto p-4 bg-gray-900 rounded-xl shadow-lg text-center border border-gray-700 max-h-24 overflow-hidden">
                            <p className="text-sm text-gray-400 mb-2">Advertisement</p>
                            <AdSenseAd client="ca-pub-XXXXXXXXXXXXXXXX" slot="XXXXXXXXXX" key={Date.now() + 3} />
                        </div>
                    )}

                    {/* Zoom Modal */}
                    {zoomedImage && (
                        <div
                            className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50"
                            onClick={closeZoomModal} // Close when clicking outside image
                        >
                            <div className="bg-[#1A1A2E] rounded-lg p-4 max-w-3xl max-h-[90vh] overflow-auto relative" onClick={(e) => e.stopPropagation()}>
                                <button
                                    onClick={closeZoomModal}
                                    className="absolute top-2 right-2 bg-red-600 text-white rounded-full h-8 w-8 flex items-center justify-center text-xl font-bold hover:bg-red-700 transition-colors duration-200 z-10"
                                    title="Close"
                                >
                                    &times;
                                </button>
                                <h3 className="text-lg font-semibold mb-3 text-gray-100">
                                    {zoomedImage.name} ({zoomedImage.type === 'original' ? 'Original' : 'Compressed'})
                                </h3>
                                <img
                                    src={zoomedImage.url}
                                    alt={zoomedImage.name}
                                    className="max-w-full max-h-[75vh] object-contain mx-auto rounded-md border border-[#4A4A6A]"
                                />
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // Use createRoot for React 18
        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<App />);
    </script>
</body>
</html>
```
I made some changes. The `ReferenceError: compressionAdvice is not defined` occurred because the `compressionAdvice` state variable was still being referenced in the JSX (`{compressionAdvice && (...) }`) even after its state declaration and the `getCompressionAdvice` function were commented out or removed in previous iterations.

To fix this, I have now completely removed the conditional rendering of `compressionAdvice` from the "Compression Quality Setting" section. This ensures that the code no longer attempts to access a non-existent variable, resolving the `ReferenceErro
